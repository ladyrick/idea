<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BASH IFS 环境变量用法总结 | LadyRick's idea</title><meta name=keywords content="bash"><meta name=description content="之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 man bash ，终于把这个 IFS 搞清楚了。
IFS 的三种作用 IFS 其实只在 3 个地方发挥作用：
用于扩展带双引号的 &#34;$*&#34; 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 用于在内建命令 read 中进行断词 可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了
IFS=xxx bash -c &#34;xxx&#34; 和
IFS=xxx read a b c 之外，任何的 IFS=xxx 临时环境变量都是不会起到任何作用的。
辅助工具 先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。
import sys for ind, arg in enumerate(sys.argv[1:], 1): print(&#34;${}: {}&#34;.format(ind, arg), flush=True) 1. 用于扩展带双引号的 $* 对于一个数组
arr=(1 2 3 4 5) &#34;${arr[@]}&#34; 会展开为 &#34;1&#34; &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;5&#34; ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。"><meta name=author content="LadyRick"><link rel=canonical href=https://idea.ladyrick.com/posts/bash-ifs-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/><link crossorigin=anonymous href=/assets/css/stylesheet.4398b09e795c3aac93a04f4160281925a588bcdf14941ead87ab7bfe555ba854.css integrity="sha256-Q5iwnnlcOqyToE9BYCgZJaWIvN8UlB6th6t7/lVbqFQ=" rel="preload stylesheet" as=style><link rel=icon href=https://idea.ladyrick.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://idea.ladyrick.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://idea.ladyrick.com/favicon-32x32.png><link rel=apple-touch-icon href=https://idea.ladyrick.com/apple-touch-icon.png><link rel=mask-icon href=https://idea.ladyrick.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="BASH IFS 环境变量用法总结"><meta property="og:description" content="之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 man bash ，终于把这个 IFS 搞清楚了。
IFS 的三种作用 IFS 其实只在 3 个地方发挥作用：
用于扩展带双引号的 &#34;$*&#34; 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 用于在内建命令 read 中进行断词 可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了
IFS=xxx bash -c &#34;xxx&#34; 和
IFS=xxx read a b c 之外，任何的 IFS=xxx 临时环境变量都是不会起到任何作用的。
辅助工具 先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。
import sys for ind, arg in enumerate(sys.argv[1:], 1): print(&#34;${}: {}&#34;.format(ind, arg), flush=True) 1. 用于扩展带双引号的 $* 对于一个数组
arr=(1 2 3 4 5) &#34;${arr[@]}&#34; 会展开为 &#34;1&#34; &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;5&#34; ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。"><meta property="og:type" content="article"><meta property="og:url" content="https://idea.ladyrick.com/posts/bash-ifs-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-14T01:10:28+08:00"><meta property="article:modified_time" content="2022-12-14T01:10:28+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="BASH IFS 环境变量用法总结"><meta name=twitter:description content="之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 man bash ，终于把这个 IFS 搞清楚了。
IFS 的三种作用 IFS 其实只在 3 个地方发挥作用：
用于扩展带双引号的 &#34;$*&#34; 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 用于在内建命令 read 中进行断词 可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了
IFS=xxx bash -c &#34;xxx&#34; 和
IFS=xxx read a b c 之外，任何的 IFS=xxx 临时环境变量都是不会起到任何作用的。
辅助工具 先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。
import sys for ind, arg in enumerate(sys.argv[1:], 1): print(&#34;${}: {}&#34;.format(ind, arg), flush=True) 1. 用于扩展带双引号的 $* 对于一个数组
arr=(1 2 3 4 5) &#34;${arr[@]}&#34; 会展开为 &#34;1&#34; &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;5&#34; ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://idea.ladyrick.com/posts/"},{"@type":"ListItem","position":2,"name":"BASH IFS 环境变量用法总结","item":"https://idea.ladyrick.com/posts/bash-ifs-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BASH IFS 环境变量用法总结","name":"BASH IFS 环境变量用法总结","description":"之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 man bash ，终于把这个 IFS 搞清楚了。\nIFS 的三种作用 IFS 其实只在 3 个地方发挥作用：\n用于扩展带双引号的 \u0026quot;$*\u0026quot; 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 用于在内建命令 read 中进行断词 可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了\nIFS=xxx bash -c \u0026#34;xxx\u0026#34; 和\nIFS=xxx read a b c 之外，任何的 IFS=xxx 临时环境变量都是不会起到任何作用的。\n辅助工具 先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。\nimport sys for ind, arg in enumerate(sys.argv[1:], 1): print(\u0026#34;${}: {}\u0026#34;.format(ind, arg), flush=True) 1. 用于扩展带双引号的 $* 对于一个数组\narr=(1 2 3 4 5) \u0026quot;${arr[@]}\u0026quot; 会展开为 \u0026quot;1\u0026quot; \u0026quot;2\u0026quot; \u0026quot;3\u0026quot; \u0026quot;4\u0026quot; \u0026quot;5\u0026quot; ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。","keywords":["bash"],"articleBody":"之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 man bash ，终于把这个 IFS 搞清楚了。\nIFS 的三种作用 IFS 其实只在 3 个地方发挥作用：\n用于扩展带双引号的 \"$*\" 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 用于在内建命令 read 中进行断词 可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了\nIFS=xxx bash -c \"xxx\" 和\nIFS=xxx read a b c 之外，任何的 IFS=xxx 临时环境变量都是不会起到任何作用的。\n辅助工具 先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。\nimport sys for ind, arg in enumerate(sys.argv[1:], 1): print(\"${}: {}\".format(ind, arg), flush=True) 1. 用于扩展带双引号的 $* 对于一个数组\narr=(1 2 3 4 5) \"${arr[@]}\" 会展开为 \"1\" \"2\" \"3\" \"4\" \"5\" ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。\nladyrick $ argsecho \"${arr[@]}\" $1: 1 $2: 2 $3: 3 $4: 4 $5: 5 ${arr[*]} 则会读取 IFS 的第一个字符，作为分隔符。设为 c，则会展开为 \"1c2c3c4c5\"。如果 IFS 为空，则直接拼接，不插入分隔符，直接展开为\"12345\"。\n$\u003e IFS=c $\u003e argsecho \"${arr[*]}\" $1: 1c2c3c4c5 bash 中凡是需要把数组展开的，都遵循这一规律。比如：\nladyrick $ set -- 1 2 3 4 5 ladyrick $ argsecho \"$@\" $1: 1 $2: 2 $3: 3 $4: 4 $5: 5 ladyrick $ IFS=c ladyrick $ argsecho \"$*\" $1: 1c2c3c4c5 再比如，根据前缀查找环境变量名：\nladyrick $ MYENV1=1 MYENV2=2 MYENV3=3 MYENV4=4 ladyrick $ argsecho \"${!MYENV@}\" $1: MYENV1 $2: MYENV2 $3: MYENV3 $4: MYENV4 ladyrick $ IFS=c ladyrick $ argsecho \"${!MYENV*}\" $1: MYENV1cMYENV2cMYENV3cMYENV4 再次强调，直接在命令前面设置临时变量 IFS 是没有用的，因为这种写法的 IFS 环境变量只会在 argsecho 命令内部生效，并不会在参数解析阶段生效。\nladyrick $ set -- 1 2 3 4 5 ladyrick $ IFS=c argsecho \"$*\" $1: 1 2 3 4 5 2. 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展 当不带双引号的这三种扩展作为命令行参数时，会根据 IFS 环境变量的值对这三种扩展的结果进行拆分，拆分成多个参数。如果 IFS 为空，则不会进行拆分。\n变量扩展 ladyrick $ args=\"1:2,3.4/5\" ladyrick $ IFS=:,./ ladyrick $ argsecho $args $1: 1 $2: 2 $3: 3 $4: 4 $5: 5 子命令扩展 ladyrick $ IFS=abcd ladyrick $ argsecho $(echo 1a2b3c4d5) $1: 1 $2: 2 $3: 3 $4: 4 $5: 5 算术扩展 ladyrick $ IFS=0 ladyrick $ argsecho $((102030400 + 5)) $1: 1 $2: 2 $3: 3 $4: 4 $5: 5 还有一些细节方面的注意点，一般不需要关注，仅供备忘查阅。\nThe shell treats each character of IFS as a delimiter, and splits the results of the other expansions into words on these characters. If IFS is unset, or its value is exactly , the default, then sequences of , , and at the beginning and end of the results of the previous expansions are ignored, and any sequence of IFS characters not at the beginning or end serves to delimit words. If IFS has a value other than the default, then sequences of the whitespace characters space and tab are ignored at the beginning and end of the word, as long as the whitespace character is in the value of IFS (an IFS whitespace character). Any character in IFS that is not IFS whitespace, along with any adjacent IFS whitespace characters, delimits a field. A sequence of IFS whitespace characters is also treated as a delimiter. If the value of IFS is null, no word splitting occurs.\n3. 用于在内建命令 read 中进行断词 这是唯一一个在命令内部生效的 IFS 用法，可以使用临时环境变量的写法。\nIFS 用于在 read 内部，把一行输入文本断为一个一个的词，然后赋值给传入的变量名。举个例子：\nladyrick $ IFS=0 read a b c \u003c\u003c\u003c 10203 ladyrick $ argsecho \"a=$a\" \"b=$b\" \"c=$c\" $1: a=1 $2: b=2 $3: c=3 这里的输入数据为10203，read 从 stdin 接收输入后，在内部读取到 IFS 为字符 '0'，所以将它拆分为了[\"1\", \"2\", \"3\"]，然后分别赋值给a b c 三个变量。\n这里还有一点需要注意，假如传入的变量数量少于分词后词的数量，那么会依次赋值，最后一个变量接收剩余所有的内容，不再进行分词。举个例子：\nladyrick $ IFS=abcde read a b c \u003c\u003c\u003c 1a2b3c4d5e6 ladyrick $ argsecho \"a=$a\" \"b=$b\" \"c=$c\" $1: a=1 $2: b=2 $3: c=3c4d5e6 注意这里 c 的获取，并不是先整体分词然后再组合，可以理解为一边分词一边赋值，最后 c 只剩一个变量，就不再分词。极端情况下，就是我们常见的只有一个变量的情况。这时也不会进行分词。\nPS：这里可能会有疑问，IFS 分词跟 read 的 -d 参数有什么区别？-d 也是作为分隔符。\n答案是，IFS 是在一行内进行分词，-d 是用来分割不同的行的。\n注意观察有没有 -d 参数的行为差别：\nladyrick $ IFS=0 read -a arr \u003c\u003c\u003c '10203 40506' ladyrick $ argsecho \"${arr[@]}\" $1: 1 $2: 2 $3: 3 ladyrick $ IFS=0 read -a arr -d '' \u003c\u003c\u003c '10203 40506' ladyrick $ argsecho \"${arr[@]}\" $1: 1 $2: 2 $3: 3 4 $4: 5 $5: 6 ladyrick $ # 思考题：为啥上面的输出 6 后面会多一个换行符？ 后记 其实 IFS 还有一个作用，是用在 complete 命令的 -W 参数中，进行分词用的。这个命令是用来进行 bash 自动补全的，比较小众，所以就不介绍了。\n","wordCount":"570","inLanguage":"zh","datePublished":"2022-12-14T01:10:28+08:00","dateModified":"2022-12-14T01:10:28+08:00","author":[{"@type":"Person","name":"LadyRick"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://idea.ladyrick.com/posts/bash-ifs-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"LadyRick's idea","logo":{"@type":"ImageObject","url":"https://idea.ladyrick.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://idea.ladyrick.com/ accesskey=h title="LadyRick's idea (Alt + H)">LadyRick's idea</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://idea.ladyrick.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://idea.ladyrick.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://idea.ladyrick.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://idea.ladyrick.com/>主页</a>&nbsp;»&nbsp;<a href=https://idea.ladyrick.com/posts/>Posts</a></div><h1 class=post-title>BASH IFS 环境变量用法总结</h1><div class=post-meta><span title='2022-12-14 01:10:28 +0800 CST'>十二月 14, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;LadyRick&nbsp;|&nbsp;<a href=https://github.com/ladyrick/idea/blob/main/content/posts/BASH-IFS-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%94%a8%e6%b3%95%e6%80%bb%e7%bb%93.md rel="noopener noreferrer" target=_blank>帮助改进</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#ifs-%e7%9a%84%e4%b8%89%e7%a7%8d%e4%bd%9c%e7%94%a8 aria-label="IFS 的三种作用">IFS 的三种作用</a><ul><li><a href=#%e8%be%85%e5%8a%a9%e5%b7%a5%e5%85%b7 aria-label=辅助工具>辅助工具</a></li><li><a href=#1-%e7%94%a8%e4%ba%8e%e6%89%a9%e5%b1%95%e5%b8%a6%e5%8f%8c%e5%bc%95%e5%8f%b7%e7%9a%84- aria-label="1. 用于扩展带双引号的 $*">1. 用于扩展带双引号的 <code>$*</code></a></li><li><a href=#2-%e7%94%a8%e4%ba%8e%e4%b8%8d%e5%b8%a6%e5%8f%8c%e5%bc%95%e5%8f%b7%e7%9a%84%e5%8f%98%e9%87%8f%e6%89%a9%e5%b1%95--%e5%ad%90%e5%91%bd%e4%bb%a4%e6%89%a9%e5%b1%95--%e7%ae%97%e6%95%b0%e6%89%a9%e5%b1%95 aria-label="2. 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展">2. 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展</a><ul><li><a href=#%e5%8f%98%e9%87%8f%e6%89%a9%e5%b1%95 aria-label=变量扩展>变量扩展</a></li><li><a href=#%e5%ad%90%e5%91%bd%e4%bb%a4%e6%89%a9%e5%b1%95 aria-label=子命令扩展>子命令扩展</a></li><li><a href=#%e7%ae%97%e6%9c%af%e6%89%a9%e5%b1%95 aria-label=算术扩展>算术扩展</a></li></ul></li><li><a href=#3-%e7%94%a8%e4%ba%8e%e5%9c%a8%e5%86%85%e5%bb%ba%e5%91%bd%e4%bb%a4-read-%e4%b8%ad%e8%bf%9b%e8%a1%8c%e6%96%ad%e8%af%8d aria-label="3. 用于在内建命令 read 中进行断词">3. 用于在内建命令 read 中进行断词</a></li></ul></li><li><a href=#%e5%90%8e%e8%ae%b0 aria-label=后记>后记</a></li></ul></div></details></div><div class=post-content><p>之前从网上找了很多关于 IFS 的二手资料，每次用每次都得再看一遍，理解还是不够透彻。最近对照着 <code>man bash</code> ，终于把这个 IFS 搞清楚了。</p><h1 id=ifs-的三种作用>IFS 的三种作用<a hidden class=anchor aria-hidden=true href=#ifs-的三种作用>#</a></h1><p>IFS 其实只在 3 个地方发挥作用：</p><ol><li>用于扩展带双引号的 <code>"$*"</code></li><li>用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展</li><li>用于在内建命令 read 中进行断词</li></ol><p>可以看到，其实只有 bash 本身和 read 命令会用到 IFS 这个环境变量。所以，除了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>IFS</span><span class=o>=</span>xxx bash -c <span class=s2>&#34;xxx&#34;</span>
</span></span></code></pre></div><p>和</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>IFS</span><span class=o>=</span>xxx <span class=nb>read</span> a b c
</span></span></code></pre></div><p>之外，任何的 <code>IFS=xxx</code> 临时环境变量都是不会起到任何作用的。</p><h2 id=辅助工具>辅助工具<a hidden class=anchor aria-hidden=true href=#辅助工具>#</a></h2><p>先写一个小的辅助程序，名为 argsecho，用于直观展示所有参数列表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>ind</span><span class=p>,</span> <span class=n>arg</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>:],</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;$</span><span class=si>{}</span><span class=s2>: </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>ind</span><span class=p>,</span> <span class=n>arg</span><span class=p>),</span> <span class=n>flush</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=1-用于扩展带双引号的->1. 用于扩展带双引号的 <code>$*</code><a hidden class=anchor aria-hidden=true href=#1-用于扩展带双引号的->#</a></h2><p>对于一个数组</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>arr</span><span class=o>=(</span><span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> 5<span class=o>)</span>
</span></span></code></pre></div><p><code>"${arr[@]}"</code> 会展开为 <code>"1" "2" "3" "4" "5"</code> ，是最忠实于原数组的展开方式。通常用于将参数列表原封不动传递给子命令。展开的过程中不涉及 IFS。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>5</span>
</span></span></code></pre></div><p><code>${arr[*]}</code> 则会读取 IFS 的第一个字符，作为分隔符。设为 c，则会展开为 <code>"1c2c3c4c5"</code>。如果 IFS 为空，则直接拼接，不插入分隔符，直接展开为<code>"12345"</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$&gt; <span class=nv>IFS</span><span class=o>=</span>c
</span></span><span class=line><span class=cl>$&gt; argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[*]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: 1c2c3c4c5
</span></span></code></pre></div><p>bash 中凡是需要把数组展开的，都遵循这一规律。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nb>set</span> -- <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>5</span>
</span></span><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>c
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=nv>$*</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: 1c2c3c4c5
</span></span></code></pre></div><p>再比如，根据前缀查找环境变量名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>MYENV1</span><span class=o>=</span><span class=m>1</span> <span class=nv>MYENV2</span><span class=o>=</span><span class=m>2</span> <span class=nv>MYENV3</span><span class=o>=</span><span class=m>3</span> <span class=nv>MYENV4</span><span class=o>=</span><span class=m>4</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=p>!MYENV@</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: MYENV1
</span></span><span class=line><span class=cl><span class=nv>$2</span>: MYENV2
</span></span><span class=line><span class=cl><span class=nv>$3</span>: MYENV3
</span></span><span class=line><span class=cl><span class=nv>$4</span>: MYENV4
</span></span><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>c
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=p>!MYENV*</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: MYENV1cMYENV2cMYENV3cMYENV4
</span></span></code></pre></div><p>再次强调，直接在命令前面设置临时变量 IFS 是没有用的，因为这种写法的 IFS 环境变量只会在 argsecho 命令内部生效，并不会在参数解析阶段生效。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nb>set</span> -- <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span>
</span></span><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>c argsecho <span class=s2>&#34;</span><span class=nv>$*</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span>
</span></span></code></pre></div><h2 id=2-用于不带双引号的变量扩展--子命令扩展--算数扩展>2. 用于不带双引号的变量扩展 / 子命令扩展 / 算数扩展<a hidden class=anchor aria-hidden=true href=#2-用于不带双引号的变量扩展--子命令扩展--算数扩展>#</a></h2><p>当不带双引号的这三种扩展作为命令行参数时，会根据 IFS 环境变量的值对这三种扩展的结果进行拆分，拆分成多个参数。如果 IFS 为空，则不会进行拆分。</p><h3 id=变量扩展>变量扩展<a hidden class=anchor aria-hidden=true href=#变量扩展>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>args</span><span class=o>=</span><span class=s2>&#34;1:2,3.4/5&#34;</span>
</span></span><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>:,./
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=nv>$args</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>5</span>
</span></span></code></pre></div><h3 id=子命令扩展>子命令扩展<a hidden class=anchor aria-hidden=true href=#子命令扩展>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>abcd
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=k>$(</span><span class=nb>echo</span> 1a2b3c4d5<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>5</span>
</span></span></code></pre></div><h3 id=算术扩展>算术扩展<a hidden class=anchor aria-hidden=true href=#算术扩展>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=k>$((</span><span class=m>102030400</span> <span class=o>+</span> <span class=m>5</span><span class=k>))</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>5</span>
</span></span></code></pre></div><p>还有一些细节方面的注意点，一般不需要关注，仅供备忘查阅。</p><blockquote><p>The shell treats each character of <strong>IFS</strong> as a delimiter, and splits the results of the other expansions into words on these characters. If <strong>IFS</strong> is unset, or its value is exactly <strong>&lt;space>&lt;tab>&lt;newline></strong>, the default, then sequences of <strong>&lt;space></strong>, <strong>&lt;tab></strong>, and <strong>&lt;newline></strong> at the beginning and end of the results of the previous expansions are ignored, and any sequence of <strong>IFS</strong> characters not at the beginning or end serves to delimit words. If <strong>IFS</strong> has a value other than the default, then sequences of the whitespace characters <strong>space</strong> and <strong>tab</strong> are ignored at the beginning and end of the word, as long as the whitespace character is in the value of <strong>IFS</strong> (an <strong>IFS</strong> whitespace character). Any character in <strong>IFS</strong> that is not <strong>IFS</strong> whitespace, along with any adjacent <strong>IFS</strong> whitespace characters, delimits a field. A sequence of <strong>IFS</strong> whitespace characters is also treated as a delimiter. If the value of <strong>IFS</strong> is null, no word splitting occurs.</p></blockquote><h2 id=3-用于在内建命令-read-中进行断词>3. 用于在内建命令 read 中进行断词<a hidden class=anchor aria-hidden=true href=#3-用于在内建命令-read-中进行断词>#</a></h2><p>这是唯一一个在命令内部生效的 IFS 用法，可以使用临时环境变量的写法。</p><p>IFS 用于在 read 内部，把一行输入文本断为一个一个的词，然后赋值给传入的变量名。举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span><span class=m>0</span> <span class=nb>read</span> a b c <span class=o>&lt;&lt;&lt;</span> <span class=m>10203</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;a=</span><span class=nv>$a</span><span class=s2>&#34;</span> <span class=s2>&#34;b=</span><span class=nv>$b</span><span class=s2>&#34;</span> <span class=s2>&#34;c=</span><span class=nv>$c</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=nv>a</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=nv>b</span><span class=o>=</span><span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=nv>c</span><span class=o>=</span><span class=m>3</span>
</span></span></code></pre></div><p>这里的输入数据为<code>10203</code>，read 从 stdin 接收输入后，在内部读取到 IFS 为字符 <code>'0'</code>，所以将它拆分为了<code>["1", "2", "3"]</code>，然后分别赋值给<code>a b c</code> 三个变量。</p><p>这里还有一点需要注意，假如传入的变量数量少于分词后词的数量，那么会依次赋值，最后一个变量接收剩余所有的内容，不再进行分词。举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span>abcde <span class=nb>read</span> a b c <span class=o>&lt;&lt;&lt;</span> 1a2b3c4d5e6
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;a=</span><span class=nv>$a</span><span class=s2>&#34;</span> <span class=s2>&#34;b=</span><span class=nv>$b</span><span class=s2>&#34;</span> <span class=s2>&#34;c=</span><span class=nv>$c</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=nv>a</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=nv>b</span><span class=o>=</span><span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=nv>c</span><span class=o>=</span>3c4d5e6
</span></span></code></pre></div><p>注意这里 c 的获取，并不是先整体分词然后再组合，可以理解为一边分词一边赋值，最后 c 只剩一个变量，就不再分词。极端情况下，就是我们常见的只有一个变量的情况。这时也不会进行分词。</p><blockquote><p>PS：这里可能会有疑问，IFS 分词跟 read 的 <code>-d</code> 参数有什么区别？<code>-d</code> 也是作为分隔符。</p><p>答案是，IFS 是在一行内进行分词，<code>-d</code> 是用来分割不同的行的。</p><p>注意观察有没有 <code>-d</code> 参数的行为差别：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span><span class=m>0</span> <span class=nb>read</span> -a arr <span class=o>&lt;&lt;&lt;</span> <span class=s1>&#39;10203
</span></span></span><span class=line><span class=cl><span class=s1>40506&#39;</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl>ladyrick $ <span class=nv>IFS</span><span class=o>=</span><span class=m>0</span> <span class=nb>read</span> -a arr -d <span class=s1>&#39;&#39;</span> <span class=o>&lt;&lt;&lt;</span> <span class=s1>&#39;10203
</span></span></span><span class=line><span class=cl><span class=s1>40506&#39;</span>
</span></span><span class=line><span class=cl>ladyrick $ argsecho <span class=s2>&#34;</span><span class=si>${</span><span class=nv>arr</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$1</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>$2</span>: <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=nv>$3</span>: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>4</span>
</span></span><span class=line><span class=cl><span class=nv>$4</span>: <span class=m>5</span>
</span></span><span class=line><span class=cl><span class=nv>$5</span>: <span class=m>6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ladyrick $ <span class=c1># 思考题：为啥上面的输出 6 后面会多一个换行符？</span>
</span></span></code></pre></div><h1 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h1><p>其实 IFS 还有一个作用，是用在 <code>complete</code> 命令的 <code>-W</code> 参数中，进行分词用的。这个命令是用来进行 bash 自动补全的，比较小众，所以就不介绍了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://idea.ladyrick.com/tags/bash/>bash</a></li></ul><nav class=paginav><a class=next href=https://idea.ladyrick.com/posts/c++-float%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F/><span class=title>下一页 »</span><br><span>C++ float数据在内存中的表示形式</span></a></nav></footer><script id=load-utterance>(()=>{const t=()=>document.body.className.split(" ").includes("dark")?"github-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("theme",t()),e.setAttribute("repo","ladyrick/idea"),e.setAttribute("issue-term","title"),e.setAttribute("crossorigin","anonymous"),e.setAttribute("url",decodeURIComponent(location.href).replace(location.origin,"https://idea.ladyrick.com")),e.setAttribute("origin","https://idea.ladyrick.com");const n=document.querySelector("#load-utterance");n.parentElement.insertBefore(e,n);const s=()=>{const e=document.querySelector(".utterances-frame");if(e){const n=t()==="github-dark"?"github-light":"github-dark",s={type:"set-theme",theme:n};e.contentWindow.postMessage(s,"https://utteranc.es")}},o=document.querySelector("#theme-toggle");o.addEventListener("click",s,!1)})()</script></article></main><footer class=footer><span>&copy; 2022 <a href=https://idea.ladyrick.com/>LadyRick's idea</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>